local players = game:GetService("Players")
local rs = game:GetService("ReplicatedStorage")
local modScript = require(game.ServerScriptService.ModuleScript)
local cdManager = require(game.ReplicatedStorage.CooldownManager)
local tweenService = game:GetService("TweenService")
local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)



local moveEvent = rs.RemoteEvents.MovementEvents.MoveEndEvent
local sprintEvent = rs.RemoteEvents.MovementEvents.sprintEvent
local jumpEvent = rs.RemoteEvents.MovementEvents.JumpEvent
local landEvent = rs.RemoteEvents.MovementEvents.LandEvent
local rollEvent = rs.RemoteEvents.MovementEvents.RollEvent



local movementManager = require(script.movementAnimsModule)


local players = game:GetService("Players")



local function yieldAllBut(hum, anim)
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		
		if v.Name ~= anim and v.Priority ~= Enum.AnimationPriority.Action and v.Priority ~= Enum.AnimationPriority.Action2 then
			v:Stop()
			print(v.Animation.Name)
		end
	end
end

local function yieldAllPlay(hum, anim, anims)
	local found = false
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		
		if v.Name ~= anim and v.Priority ~= Enum.AnimationPriority.Action and v.Priority ~= Enum.AnimationPriority.Action2 and Enum.AnimationPriority.Movement then
			v:Stop(0.1)
			--print(v.Name)
		elseif v.Name == anim then
			found = true
		end
		
	end
	if found == false then
		--print("NotFound")
		anims[anim]:Play()
	end
end





sprintEvent.OnServerEvent:Connect(function(player, value)
	local character = player.Character
	character:SetAttribute("Sprinting", value)
end)

moveEvent.OnServerEvent:Connect(function(player, value)

	
	
	local character = player.Character
	character:SetAttribute("NetDirection", value)
	local hum = character:WaitForChild("Humanoid")
	--yieldAllBut(player.Character.Humanoid, "")

	local anims = movementManager:GetAnimations(player.Character)
	if not anims then return end
	
	if character:GetAttribute("Sprinting") == false then
		local checks = modScript.checkAll(player)
		if checks == false then return end
		
		character:SetAttribute("Speed", 16)
		character.Humanoid.WalkSpeed = character:GetAttribute("Speed") + character:GetAttribute("SpeedBuff")
		if character:GetAttribute("NetDirection") == "w" then
			if player.Character:GetAttribute("Weapon") == "SpawnedScythe" then
				yieldAllPlay(player.Character.Humanoid, "scytheWalk", anims)
			else
				yieldAllPlay(player.Character.Humanoid, "walk", anims)
			end
		elseif character:GetAttribute("NetDirection") == "a" then
			if player.Character:GetAttribute("Weapon") == "SpawnedScythe" then
				yieldAllPlay(player.Character.Humanoid, "scytheWalk", anims)
			else
				yieldAllPlay(player.Character.Humanoid, "leftLean", anims)
			end
		elseif character:GetAttribute("NetDirection") == "d" then
			if player.Character:GetAttribute("Weapon") == "SpawnedScythe" then
				yieldAllPlay(player.Character.Humanoid, "scytheWalk", anims)
			else
				yieldAllPlay(player.Character.Humanoid, "rightLean", anims)
			end
		elseif character:GetAttribute("NetDirection") == "s" then
			if player.Character:GetAttribute("Weapon") == "SpawnedScythe" then
				yieldAllPlay(player.Character.Humanoid, "scytheWalk", anims)
			else
				yieldAllPlay(player.Character.Humanoid, "walk", anims)
			end
		end

	elseif character:GetAttribute("Sprinting") == true then 
		local checks = modScript.checkAll(player)
		if checks == false then return end
		character:SetAttribute("Speed", 24)
		character.Humanoid.WalkSpeed = character:GetAttribute("Speed") + character:GetAttribute("SpeedBuff")
		
		if character:GetAttribute("NetDirection") == "w" then
			if player.Character:GetAttribute("Weapon") == "SpawnedScythe" then
				yieldAllPlay(player.Character.Humanoid, "scytheRun", anims)
			else
				yieldAllPlay(player.Character.Humanoid, "sprint", anims)
			end
		elseif character:GetAttribute("NetDirection") == "a" then
			if player.Character:GetAttribute("Weapon") == "SpawnedScythe" then
				yieldAllPlay(player.Character.Humanoid, "scytheRun", anims)
			else
				yieldAllPlay(player.Character.Humanoid, "leftSprint", anims)
			end
		elseif character:GetAttribute("NetDirection") == "d" then
			if player.Character:GetAttribute("Weapon") == "SpawnedScythe" then
				yieldAllPlay(player.Character.Humanoid, "scytheRun", anims)
			else
				yieldAllPlay(player.Character.Humanoid, "rightSprint", anims)
			end
			
		end
	end
	if character:GetAttribute("NetDirection") == "" then
		--print("playIdle")
		if player.Character:GetAttribute("Weapon") == "SpawnedScythe" then
			yieldAllPlay(player.Character.Humanoid, "scytheIdle", anims)
			--player.Character.SpawnedScythe.Handle.Motor6D.C1 
		else
			yieldAllPlay(player.Character.Humanoid, "idle", anims)

		end 
	end
	
end)


--
jumpEvent.OnServerEvent:Connect(function(player)
	local checks = modScript.checkAll(player)
	if checks == false or player.Character:GetAttribute("Busy") == true then return end
	modScript.yieldAllBut(player.Character, "")
	local anims = movementManager:GetAnimations(player.Character)
	anims.startJump:Play(0)
end)

landEvent.OnServerEvent:Connect(function(player)

	yieldAllBut(player.Character.Humanoid, "")

	local anims = movementManager:GetAnimations(player.Character)
	--modScript.createHitEffect(player.Character.HumanoidRootPart.Position + Vector3.new(0, -10, 0), rs.VFX.movementDust)
	anims.endJump:Play()

	modScript.stun(player.Character, 1)
	task.wait()
	anims.endJump.Stopped:Connect(function()
	
		moveEvent:FireClient(player)
	end)

	
	
end)

local draw = function(p1, p2, x, y)
	local dist = (p2.Position-p1.Position).Magnitude
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Color = Color3.fromRGB(137, 243, 255)
	part.Material = Enum.Material.Neon
	part.Size = Vector3.new(0.6-x, 0.6-y, dist)
	part.CFrame = CFrame.new(p1.Position, p2.Position) * CFrame.new(0, 0, -1*dist/2)
	
	local partt = rs.VFX.KilluaVFX.lineTPAttHolder:Clone()
	local att = partt.lineTPAtt:Clone()

	partt:Destroy()
	att.Parent = part

	
	part.Parent = game.Workspace

	local tween = tweenService:Create(part, tweenInfo, {Transparency = 1}):Play()
	--local tween2 = tweenService:Create(spart, tweenInfo, {Transparency = 1}):Play()
	--game:GetService("Debris"):AddItem(spart, 1)
	game:GetService("Debris"):AddItem(part, 1)

end

local createLightningTrail = function(makePos, dashDir)
	local addZ = 0
	local x= 0
	local y = 0
	for i=1, 5, 1 do
		local part = Instance.new("Part")
		part.Name = "BezierPoint"..tostring(i)
		local randX = math.random(-2, 2)
		local randY = math.random(-0.3, 0.3)
		
		local offset = dashDir * addZ
		local sideOffset = dashDir:Cross(Vector3.yAxis) * randX
		local heightOffset = Vector3.new(0, 1+randY, 0)

		local finalPos = makePos + offset + sideOffset + heightOffset
		
		part.Position = finalPos
		part.Anchored = true
		part.CanCollide = false
		part.BrickColor= BrickColor.new("Medium blue")
		part.Material = Enum.Material.Neon
		part.Size = Vector3.new(0.5, 0.5, 0.5)
		part.CFrame = CFrame.new(finalPos, finalPos + dashDir)
		part.Transparency = 1
		part.Parent = game.Workspace
		addZ= addZ+3.5
		x = x+0.1
		y = y+0.1
		game:GetService("Debris"):AddItem(part, 1)
		if i>1 then
			draw(game.Workspace["BezierPoint"..tostring((i-1))], part, x, y)
		end
	end
end


rollEvent.OnServerEvent:Connect(function(player)
	local animator = player.Character.Humanoid:FindFirstChild("Animator")
	local checks = modScript.checkAll(player)
	if checks == false or player.Character:GetAttribute("Busy") == true then return end
	
	if cdManager.IsOnCooldown(player, "Q") then
	
		return
	else
		if player.Character:GetAttribute("NenAbility") == "Killua" then
			if player.Character:GetAttribute("GodSpeed") == true then
				cdManager.SetCooldown(player, "Q", 1)
			else
				cdManager.SetCooldown(player, "Q", 2)
			end
		else
			cdManager.SetCooldown(player, "Q", 2)
		end
	end	
	
	player.Character:SetAttribute("Dashing", true)
	player.Character:SetAttribute("Busy", true)
	local anims = movementManager:GetAnimations(player.Character)

	
	

	local hrp = player.Character.PrimaryPart
	local moveDir = player.Character.Humanoid.MoveDirection
	moveDir = Vector3.new(moveDir.X, 0, moveDir.Z).Unit
	
	if player.Character:GetAttribute("GodSpeed") == false then
		if player.Character:GetAttribute("NetDirection") == "w" then
			anims.roll:Play()
		elseif player.Character:GetAttribute("NetDirection") == "s" then
			anims.backRoll:Play()

		elseif player.Character:GetAttribute("NetDirection") == "a" then
			anims.leftRoll:Play()
		elseif player.Character:GetAttribute("NetDirection") == "d" then
			anims.rightRoll:Play()
		end
		
		if player.Character:GetAttribute("NetDirection") == "" then
			anims.roll:Play()
		end	
	end
	
	if player.Character:GetAttribute("NetDirection") == "" then
		moveDir = hrp.CFrame.LookVector
	end	

	
	if player.Character:GetAttribute("GodSpeed") == true then
		task.wait(0.1)
		local dashDistance = 25
		local rayParams = RaycastParams.new()
		rayParams.FilterDescendantsInstances = {player.Character}
		rayParams.FilterType = Enum.RaycastFilterType.Exclude
		local result = workspace:Raycast(hrp.Position, moveDir * dashDistance, rayParams)

		local targetPos = hrp.Position + moveDir * dashDistance
		if result then
			targetPos = result.Position - moveDir * 2 
		end
		
		
		
		
		hrp.CFrame = CFrame.new(targetPos, targetPos + hrp.CFrame.LookVector)
		
		task.spawn(function()
			local boostVFX = rs.VFX.KilluaVFX.BoostVFX:Clone()
			boostVFX.CFrame = CFrame.new(hrp.Position, hrp.Position + moveDir)
			boostVFX.Parent = game.Workspace
			task.wait(0.05)
			for _, emitter in pairs(boostVFX.Core:GetChildren()) do
				emitter:Emit(emitter:GetAttribute("EmitCount"))
			end
		
			
		end)
		
		for _, v in pairs(player.Character:GetChildren()) do
			if v.Name == "Torso" then
				createLightningTrail(v.Position, moveDir*-1)
			end
		end
		task.wait(0.08)
	else 
		local bv = Instance.new("BodyVelocity")
		bv.MaxForce = Vector3.new(1e8, 0, 1e8)  
		bv.Parent = hrp
		bv.Velocity = moveDir * (70)
		task.wait(0.2)
		bv:Destroy()
		
		local function roll(dummy, dir)
	local animator = dummy.Humanoid:FindFirstChild("Animator")
	if dummy:GetAttribute("Stunned") == true or dummy:GetAttribute("Attacking") == true or dummy:GetAttribute("Dashing") == true then return end

	
	local hrp = dummy.PrimaryPart
	local moveDir = dummy.Humanoid.MoveDirection
	moveDir = Vector3.new(moveDir.X, 0, moveDir.Z).Unit
	
	if dir == "Back" then
		moveDir = moveDir * -1
	end
	
	dummy:SetAttribute("Dashing", true)
	--player.Character:SetAttribute("Busy", true)
	local anim = rs.MovementAnims.backRollAnim
	local clip = animator:LoadAnimation(anim)
	clip:Play()

	hrp.AssemblyLinearVelocity = moveDir * 70
	task.wait(0.17)
	hrp.AssemblyLinearVelocity = Vector3.zero
	
	task.spawn(function()
		task.wait(2)
		dummy:SetAttribute("Dashing", false)
	end)
end
	end	

	

	task.wait(0.5)
	player.Character:SetAttribute("Dashing", false)
	player.Character:SetAttribute("Busy", false)
	moveEvent:FireClient(player)
	
end)

local climbRange = 4     -- how far to check in front
local climbHeight = 6    -- max ledge height
local climbUp = 5        -- how much to move up

local function getLedge(player)
	local hrp = player.Character.PrimaryPart
	local rayOrigin = hrp.Position
	local rayDirection = hrp.CFrame.LookVector * climbRange
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {player.Character}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude

	local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
	if result then
		print(result.Instance.Name)
		local ledgePos = result.Instance.Position
		local topY = ledgePos.Y + (result.Instance.Size.Y / 2)
		local heightDiff = topY-(hrp.Position.Y)
		if heightDiff < climbHeight then
			return topY
		end
	end
	return nil
end

rs.RemoteEvents.MovementEvents.ClimbEvent.OnServerEvent:Connect(function(player)
	local ledgeGoalPos = getLedge(player)
	local hrp = player.Character.PrimaryPart
	if ledgeGoalPos then
		local bodyVelocity = Instance.new("BodyVelocity")
		bodyVelocity.Velocity = Vector3.new(0, 25, 0)  
		bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
		bodyVelocity.P = 1000
		bodyVelocity.Parent = hrp
		game:GetService("Debris"):AddItem(bodyVelocity, 0.4)
	end
end)
